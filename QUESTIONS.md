

## ExecuteBlockEphemerally

Goal: reads block from stateReader, runs it and writes the result to stateWriter

	 
- InitializeBlockExecution: pretty much a no-op (suppose to set the epoch etc.)
- DaoHardFork state changes (modifies the state database - refunds to certain accounts)
- For each transaction:
  - apply the transaction
  - write the traces (bool); append receipt (bool)
- create bloom filter (bool)
- finalize block execution (bool) - reward to miner + commit the in-memory changes resulting from the block
- some special handling for Bor consensus




questions:
- how do you create a state reader for a block
- where is the output of traces (when each tx is executed)?
- where is receipts/bloom filters written? Where is it ultimately persisted?
- in general what are the inputs to ExecuteBlockEphemerally

cmd/evm
- what are the differences compared to above? -- output destinations; not persisting changes; any additional logic for forks/consensus;





PlainStateReader
- read account state, and deref the "foreign keys" like codehash/storage root  (can do in-memory change batch capturing, which can be committed to a backing RwTx)
- Q: can it update the account states as the block changes it? (yeah, PlainStateWriter is based on the backing batch capturing persistence layer) 

PlainStateWriter
- update account state, and other deferenced data
- in-memory change capturing. (DbWithPendingMutations)
- if changeSet writing is enabled, optionally maintains in-memory changeset, which is then committed to changeset bucket in the KV.
- also writes in "accumulator" which powers the RPC.


RwDb: db on top of the chaindata; common interface over MDBX and RemoteKV
RwTx: transaction (generated by RwDb#BeginTx) which can be committed at last etc.

AccountChangeSet/StorageChangeSet
- at block N, stores the value of state before block N changed them. The values "after" change is stored in PlainState (separate "table")
- so if block N changed account A from value X to Y, then:
  - AccountChangeSet has record: N + A -> X
  - PlainState has record: A -> Y



IntraBlockState:
- maintains a journal of changes & also source of data for EVM execution
- we need to basically populate the StateReader with the witness, which should then power the IntraBlockState




---
cmd/evm2.go

BlockExecuteEphmerally



cli-tool:
1.
inputs: block-specimen, block
output: 
2. block-specimen => block
3. set of inputs





## cmd/evm.go

```bash
./build/bin/evm t8n --input.alloc cmd/evm/testdata/1/alloc.json --input.txs cmd/evm/testdata/1/txs.json --input.env cmd/evm/testdata/1/env.json   --output.basedir moskud_out --output.alloc alloc_out.txt --output.result result_out.txt
```

### input:
- mining reward value
- alloc.json: account state (at genesis)
```json
{
  "0x095e7baea6a6c7c4c2dfeb977efac326af552d87" : {
    "balance" : "0x0de0b6b3a7640000",
    "code" : "0x6001600053600160006001f0ff00",
    "nonce" : "0x00",
    "storage" : {
    }
  }
}
```

- txs.json
```json
[
  {
    "input" : "0x",
    "gas" : "0x5f5e100",
    "gasPrice" : "0x1",
    "nonce" : "0x0",
    "to" : "0x095e7baea6a6c7c4c2dfeb977efac326af552d87",
    "value" : "0x186a0",
    "v" : "0x1b",
    "r" : "0x88544c93a564b4c28d2ffac2074a0c55fdd4658fe0d215596ed2e32e3ef7f56b",
    "s" : "0x7fb4075d54190f825d7c47bb820284757b34fd6293904a93cddb1d3aa961ac28",
    "hash" : "0x72fadbef39cd251a437eea619cfeda752271a5faaaa2147df012e112159ffb81"
  }
]
```

- env.json: core/vm/runtime/runtime.go#Config
```json
{
  "currentCoinbase" : "0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba",
  "currentDifficulty" : "0x020000",
  "currentGasLimit" : "0x3b9aca00",
  "currentNumber" : "0x01",
  "currentTimestamp" : "0x03e8"
}
```

### Steps

- set the base directory (for output)
- set the tracing (via evm logger) -- stack, storage, memory, return data, debug (?)
  - a lambda is created, which for every (txIndex, txHash) returns a tracefile backed json-logger, which can put the tracing info in there.
- load 3 things: alloc, env & transactions. It can be taken from stdin or files.
  - serialization: `Prestate` consists of Pre (Alloc info) and Env; `txs` are maintained separately.
- create vm Config (Interpreter config) with tracer (which is null currently)
- load "chain config" from `ForknameFlag`
  - `GetChanConfig` takes a fork definition and returns a chain config.
  - fork definition can be (i) plain forkname or (ii) fork basename, and a list of EIPs to enable
  - ChainConfig: forks + eips + consensus engine config
- sign the unsigned transactions
- env check for EIP-1559 (currentBaseFee should be present)
- `Apply transactions to the prestate
  - setup `getHash(blockheight int)` lambda
  - create in memory RwDb and RwTx
- output the results:
  - alloc: `GenesisAccount map` (account state map)
  - result: `ExecutionResult` (state root, tx root, receipt root, bloom, rejected txs etc.)
  - body: rlp encoded txs


### Questions
- params#ChainConfig: how do we know which eip or forks or consensus engine apply?
